use hex_literal::hex;
use hidapi::{HidApi, HidDevice};

const ALPHA_BASE: u8 = b'A' - 61;
const NUMERIC_BASE: u8 = ALPHA_BASE + 26;


#[derive(Clone, Copy)]
#[repr(u8)]
enum MouseButton {
    LeftClick = 0x01,
    RightClick = 0x02,
    MiddleClick = 0x03,
    Mouse4 = 0x04,
    Mouse5 = 0x05,
    Scrollup = 0x09,
    Scrolldown = 0x0a,
    ScrollLeft = 0x34,
    ScrollRight = 0x35,
    Side1 = 0x40,
    Side2 = 0x41,
    Side3 = 0x42,
    Side4 = 0x43,
    Side5 = 0x44,
    Side6 = 0x45,
    Side7 = 0x46,
    Side8 = 0x47,
    Side9 = 0x48,
    Side10 = 0x49,
    Side11 = 0x4a,
    Side12 = 0x4b
}

/// May be possible to do both mouse and keyboard functions at the same time? I'd need to see how the layout would work.
enum DeviceType {
    Mouse(MouseButton, MouseButton),
    Keyboard(MouseButton, u8),
}

struct Function {
    r#type: DeviceType,
    turbo: u16 // code 0x0b; repeat action every N milliseconds
}

fn generate_function_string(func: &Function) -> [u8; 8] {
    let mut string = [0u8; 8];
    // Presumed byte meanings:
    // 0: physical mouse button
    // 1: 0x01: emulate a mouse button
    //    0x02: emulate a keyboard button
    //    0x0d: emulate button as turbo
    // 2: 0x01: emulate a mouse button
    //    0x02: emulate a keyboard button
    //    0x02: emulate (mouse) button as turbo
    //    0x04: emulate (keyboard) button as turbo
    // 3: if emulating a keyboard button, zero. (However, this MAY always be emulated MouseButton value?)
    //    if emulating a mouse button, the MouseButton value

    // 4: this is where it gets tricky:
    //    if emulating a keyboard button, the KeyboardButton value
    //    if emulating a mouse button, and if turbo: milliseconds between button presses as u16

    match func.r#type {
        DeviceType::Mouse(physical_button, emulate_button) => {
            string[0] = physical_button as _;
            string[2] = 0x01;
            string[3] = 0x01;
            string[4] = emulate_button as _;
            if func.turbo > 0 {
                string[2] |= 0x0d;
                string[3] |= 0x02;
                let data = func.turbo.to_be_bytes();
                string[5] = data[0];
                string[6] = data[1];
            }
        },
        DeviceType::Keyboard(physical_button, keyboard_button) => {
            string[0] = physical_button as _;
            string[2] = 0x01;
            string[3] = 0x01;
            string[4] = 0x00;
            string[5] = keyboard_button;
            if func.turbo > 0 {
                string[2] |= 0x0d;
                string[3] = 0x04;
                let data = func.turbo.to_be_bytes();
                string[6] = data[0];
                string[7] = data[1];
            }
        },
    }
    string
}

fn main() {
    println!("Printing all available hid devices:");

    match HidApi::new() {
        Ok(api) => {
            for device in api.device_list() {
                let vid = device.vendor_id();
                let pid = device.product_id();
                // println!("{:04x}:{:04x}", vid,pid );
                if vid == 0x1532 && pid == 0x00b4 {
                    if device.interface_number() != 0 {
                        continue
                    }
                    // if let Some(ps) = device.product_string() {
                    //     println!("ps: {ps:?}")
                    // }
                    // if let Some(ser) = device.serial_number() {
                    //     println!("ser: {ser}")
                    // }
                    // println!("interface number: {}", device.interface_number());
                    println!("path: {}", device.path().to_string_lossy());
                    // if vid == 0x1532 {
                    //     println!("razer!");
                    // }
                    // if pid == 0x00b4 {
                    //     println!("naga v2 hyperspeed!");
                    // }
                    let mousey = api.open_path(device.path()).unwrap();
                    let mut message = [0u8; 91];
                                    // Byte number: Comment
                    message[0] = 0; // 0: Report ID: Needed strictly for the API, doesn't actually get sent to the mouse in this position, so everything else is basically off by one.
                    message[1] = 0; // 1: I think either this or 3 might be an extended checksum
                    message[2] = 0x1f; // 1: Part of the checksum calculation. Basically this and byte 89 (byte 88 in the actual usb message) need to xor to zero or else the message (I think) is considered corrupted and is dropped.
                    message[3] = 0; // 1: Same as byte 1
                    let dunno = [0x00, 0x00, 0x0a, 0x02, 0x0c, 0x01]; // 4-9: No idea what any of this is. Internal packet header or packet magic possibly? None of the numbers make any sense to me.
                    message[4..10].clone_from_slice(&dunno);
                    let func_bytes = generate_function_string(&Function { r#type: DeviceType::Mouse(MouseButton::Side10, MouseButton::Mouse4), turbo: 0 });
                    message[10..18].clone_from_slice(&func_bytes);
                    message[89] = message[3..].iter().fold(0, |acc, x| acc ^ x); // iterate through everything after the checksum seed and xor all bytes together

                    match mousey.send_feature_report(&message) {
                        Ok(ok) => {println!("awesome!"); break},
                        Err(err) => {println!("poo"); continue}
                    }


                     let abytes01 = hex!("00001f0000000a020c01400002020004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004100");
                     let abytes11 = hex!("00001f0000000a020c014a0002020004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004b00");
                  let abytes11t20 = hex!("00001f0000000a020c014a000d040004003200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007000");
                     let abytes12 = hex!("00001f0000000a020c014b0002020004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004a00");
                    let f1bytes12 = hex!("00001f0000000a020c014b000202003a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007400");
                   let f12bytes12 = hex!("00001f0000000a020c014b0002020045000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b00");
                   let f13bytes12 = hex!("00001f0000000a020c014b0002020068000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002600");
                   let f24bytes12 = hex!("00001f0000000a020c014b0002020073000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003d00");
                     let abytesrc = hex!("00001f0000000a020c01020002020004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300");
                     let abytessl = hex!("00001f0000000a020c01340002020004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003500");
                     let abytessr = hex!("00001f0000000a020c01350002020004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003400");
                     let abytessu = hex!("00001f0000000a020c01090002020004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800");
                     let abytessd = hex!("00001f0000000a020c010a0002020004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b00");
                     let abytessc = hex!("00001f0000000a020c01030002020004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200");
                    let m4bytes11 = hex!("00001f0000000a020c014a0001010400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004b00");
                    let m5bytes12 = hex!("00001f0000000a020c014b0001010500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004b00");
                 let m5bytes12t01 = hex!("00001f0000000a020c014b000e030503e8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ad00");
                    let rcbytesrc = hex!("00001f0000000a020c01020001010200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500");
                    let rcbyrct01 = hex!("00001f0000000a020c0102000e030203e8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e300");
                    let rcbyrct02 = hex!("00001f0000000a020c0102000e030201f4000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000fd00");
                    //                                                            ^^^^ # of milliseconds between repetitions as u16, 0x01f4 == 500ms, e.g. two clicks per second                                                      ^^ checksum?
                    let rcbyrct03 = hex!("00001f0000000a020c0102000e0302014d0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004400");
                    let rcbyrct04 = hex!("00001f0000000a020c0102000e030200fa000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f200");
                    let rcbyrct20 = hex!("00001f0000000a020c0102000e030200320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003a00");
                     let rcbytelc = hex!("00001f0000000a020c01020001010100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000600");
                     let lcbyterc = hex!("00001f0000000a020c01010001010200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000600");
                     let lcbytelc = hex!("00001f0000000a020c01010001010100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500");
                     let bbytes12 = hex!("00001f0000000a020c014b0002020005000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004b00");
                    // let cbytes = hex!("00001f0000000a020c014a0002020006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004900");

                    // let dbytes = hex!("00001f0000000a020c014a0002020007000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004800");
                    // let ebytes = hex!("00001f0000000a020c014a0002020008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004700");
                    // let fbytes = hex!("00001f0000000a020c014a0002020009000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004600");
                    // let gbytes = hex!("00001f0000000a020c014a000202000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004500");
                    // let hbytes = hex!("00001f0000000a020c014a000202000b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004400");
                    // let ibytes = hex!("00001f0000000a020c014a000202000c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004300");
                    // let jbytes = hex!("00001f0000000a020c014a000202000d000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004200");
                    // let kbytes = hex!("00001f0000000a020c014a000202000e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004100");
                    // let lbytes = hex!("00001f0000000a020c014a000202000f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000");
                    // let mbytes = hex!("00001f0000000a020c014a0002020010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005f00");
                    // let nbytes = hex!("00001f0000000a020c014a0002020011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005e00");
                    // let obytes = hex!("00001f0000000a020c014a0002020012000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005d00");
                    // let pbytes = hex!("00001f0000000a020c014a0002020013000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005c00");
                    // let qbytes = hex!("00001f0000000a020c014a0002020014000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005b00");
                    // let rbytes = hex!("00001f0000000a020c014a0002020015000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005a00");
                    // let sbytes = hex!("00001f0000000a020c014a0002020016000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005900");
                    // let tbytes = hex!("00001f0000000a020c014a0002020017000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005800");
                    // let ubytes = hex!("00001f0000000a020c014a0002020018000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005700");
                    // let vbytes = hex!("00001f0000000a020c014a0002020019000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005600");
                    // let wbytes = hex!("00001f0000000a020c014a000202001a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005500");
                    // let xbytes = hex!("00001f0000000a020c014a000202001b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005400");
                    // let ybytes = hex!("00001f0000000a020c014a000202001c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005300");

                    // let zbytes = hex!("00001f0000000a020c014a000202001d000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005200");

                    // let n1 = hex!("00001f0000000a020c014a000202001e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005100");
                    // let n2 = hex!("00001f0000000a020c014a000202001f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000");
                    // let n3 = hex!("00001f0000000a020c014a0002020020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006f00");
                    // let n4 = hex!("00001f0000000a020c014a0002020021000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006e00");
                    // let n5 = hex!("00001f0000000a020c014a0002020022000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006d00");
                    // let n6 = hex!("00001f0000000a020c014a0002020023000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006c00");
                    // let n7 = hex!("00001f0000000a020c014a0002020024000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006b00");
                    // let n8 = hex!("00001f0000000a020c014a0002020025000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006a00");
                    // let n9 = hex!("00001f0000000a020c014a0002020026000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006900");
                    // let n0 = hex!("00001f0000000a020c014a0002020027000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006800");

                    println!("message: {message:02x?}");
                    println!("control: {m4bytes11:02x?}");
                    assert_eq!(message, m4bytes11);
                    println!("yay!");
                    // let mut buf = Vec::new();
                    // buf.push(0);
                    // let reply_len = mousey.get_feature_report(&mut buf).unwrap();
                    // println!("reply len: {reply_len} reply: {:04x?}", buf)
                }
            }
        },
        Err(e) => {
            eprintln!("Error: {}", e);
        },
    }
}
